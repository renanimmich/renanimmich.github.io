<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Passarinho — Mobile</title>
<style>
  html,body{height:100%;margin:0;background:#70c5ce;font-family:Inter,system-ui,Arial; -webkit-touch-callout:none; -webkit-user-select:none;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none; -webkit-tap-highlight-color: transparent;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  let DPR = window.devicePixelRatio || 1;
  let vw = window.innerWidth, vh = window.innerHeight;

  // sizes (recalculados no resize)
  let bird = { x: 80, y: 200, r: 14, vy: 0, rot: 0 };
  let gravity = 0.6, jumpPower = 10;
  let pipeW = 52, pipeGap = 140, baseSpeed = 140;
  let pipes = [];
  let lastPipeAt = 0, pipeInterval = 1500;
  let state = 'menu'; // menu | playing | over
  let score = 0, best = Number(localStorage.getItem('flap_best') || 0);
  let lastTime = 0;
  let audioReady = false;

  // ---- Audio (WebAudio procedural) ----
  const Snd = {
    ctx: null,
    ensure() {
      if (!this.ctx) {
        const C = window.AudioContext || window.webkitAudioContext;
        if (!C) return null;
        this.ctx = new C();
      }
      return this.ctx;
    },
    resumeIfNeeded() {
      if(!this.ctx) return;
      if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    flap() {
      const ctx = this.ensure(); if(!ctx) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 440;
      g.gain.value = 0.12;
      o.connect(g); g.connect(ctx.destination);
      o.start(); o.stop(ctx.currentTime + 0.06);
    },
    point() {
      const ctx = this.ensure(); if(!ctx) return;
      const t = ctx.currentTime;
      const o1 = ctx.createOscillator();
      const g = ctx.createGain();
      o1.type = 'triangle'; o1.frequency.setValueAtTime(880, t);
      g.gain.value = 0.12;
      o1.connect(g); g.connect(ctx.destination);
      o1.start(); o1.stop(t + 0.08);
    },
    hit() {
      const ctx = this.ensure(); if(!ctx) return;
      const bufferSize = ctx.sampleRate * 0.2;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++){
        data[i] = (Math.random()*2 -1) * Math.exp(-3 * i / bufferSize);
      }
      const src = ctx.createBufferSource();
      const g = ctx.createGain();
      src.buffer = buffer;
      g.gain.value = 0.25;
      src.connect(g); g.connect(ctx.destination);
      src.start();
    }
  };

  // ---- resize / scale ----
  function resize(){
    DPR = window.devicePixelRatio || 1;
    vw = window.innerWidth; vh = window.innerHeight;
    canvas.style.width = vw + 'px';
    canvas.style.height = vh + 'px';
    canvas.width = Math.floor(vw * DPR);
    canvas.height = Math.floor(vh * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    // scale sizes to screen
    bird.r = Math.max(10, vh * 0.035);
    bird.x = Math.max(60, vw * 0.22);
    gravity = Math.max(0.45, vh * 0.0009);
    jumpPower = Math.max(8, vh * 0.03);
    pipeW = Math.max(44, vw * 0.14);
    pipeGap = Math.max(110, vh * 0.20);
    baseSpeed = Math.max(140, vw * 0.25);
  }
  window.addEventListener('resize', resize);
  resize();

  // ---- helpers ----
  function rand(min,max){ return Math.random()*(max-min)+min; }

  // ---- game control ----
  function reset() {
    bird.y = vh/2; bird.vy = 0; bird.rot = 0;
    pipes = [];
    score = 0;
    lastPipeAt = 0;
    state = 'menu';
  }

  function startGame() {
    reset(); state = 'playing'; lastPipeAt = performance.now() + 200;
  }

  function spawnPipe() {
    const topH = rand(40, vh - pipeGap - 80);
    pipes.push({ x: vw + pipeW, top: topH, passed: false });
  }

  function gameOver() {
    if (state !== 'over') {
      state = 'over';
      Snd.hit();
      if (score > best) { best = score; localStorage.setItem('flap_best', best); }
    }
  }

  // ---- input ----
  function flap() {
    bird.vy = -jumpPower;
    Snd.flap();
  }

  canvas.addEventListener('pointerdown', (e) => {
    // first interaction: allow audio
    Snd.ensure(); Snd.resumeIfNeeded(); audioReady = true;

    if (state === 'menu') {
      startGame();
      flap();
    } else if (state === 'playing') {
      flap();
    } else if (state === 'over') {
      startGame();
    }
  });
  // keyboard support
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      if (state === 'menu') { startGame(); flap(); }
      else if (state === 'playing') flap();
      else if (state === 'over') startGame();
    }
  });

  // ---- update / draw loop ----
  function update(dt) {
    if (state === 'playing') {
      // physics
      bird.vy += gravity * (dt / 16.666);
      bird.y += bird.vy * (dt / 16.666);

      bird.rot = Math.max(-0.6, Math.min(1.2, bird.vy / 20));

      // move pipes
      const speed = baseSpeed * (dt / 1000);
      for (let p of pipes) p.x -= speed * 60; // scale so baseSpeed approximates px/sec
      // remove offscreen
      pipes = pipes.filter(p => p.x > -pipeW - 20);

      // spawn
      if (performance.now() - lastPipeAt > pipeInterval) { spawnPipe(); lastPipeAt = performance.now(); }

      // collisions & scoring
      for (let p of pipes) {
        // score
        if (!p.passed && p.x + pipeW < bird.x) { p.passed = true; score++; Snd.point(); }
        // collision rough-check
        if (bird.x + bird.r > p.x && bird.x - bird.r < p.x + pipeW) {
          if (bird.y - bird.r < p.top || bird.y + bird.r > p.top + pipeGap) {
            gameOver();
          }
        }
      }

      // ground/ceiling
      const groundY = vh - Math.max(32, vh * 0.08);
      if (bird.y + bird.r >= groundY) { bird.y = groundY - bird.r; gameOver(); }
      if (bird.y - bird.r <= 0) { bird.y = bird.r; bird.vy = 0; }
    } else if (state === 'menu') {
      // gentle bob
      bird.y = vh * 0.45 + Math.sin(performance.now()/450) * (vh*0.01);
    } else if (state === 'over') {
      // let bird fall a bit for effect
      if (bird.y + bird.r < vh - Math.max(32, vh * 0.08)) {
        bird.vy += gravity * (dt / 16.666);
        bird.y += bird.vy * (dt / 16.666);
      }
      bird.rot = Math.min(1.4, bird.rot + 0.02 * (dt/16.666));
    }
  }

  function draw() {
    // background sky
    ctx.fillStyle = '#70c5ce';
    ctx.fillRect(0,0,vw,vh);

    // clouds / simple
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    for (let i=0;i<6;i++){
      ctx.beginPath();
      const cx = (i*123 + (performance.now()/40) % vw) % vw;
      const cy = 40 + (i%3)*30;
      ctx.ellipse(cx, cy, 80, 24, 0, 0, Math.PI*2);
      ctx.fill();
    }

    // pipes
    ctx.fillStyle = '#2b8a2b';
    for (let p of pipes) {
      // top
      ctx.fillRect(p.x, 0, pipeW, p.top);
      // bottom
      ctx.fillRect(p.x, p.top + pipeGap, pipeW, vh - (p.top + pipeGap) - Math.max(32, vh * 0.08));
      // pipe cap (simple)
      ctx.fillStyle = '#228022';
      ctx.fillRect(p.x - 4, p.top - 8, pipeW + 8, 8);
      ctx.fillRect(p.x - 4, p.top + pipeGap, pipeW + 8, 8);
      ctx.fillStyle = '#2b8a2b';
    }

    // ground
    const groundH = Math.max(32, vh * 0.08);
    ctx.fillStyle = '#DEB887';
    ctx.fillRect(0, vh - groundH, vw, groundH);
    // ground pattern
    ctx.fillStyle = '#caa87f';
    for (let x=0;x<vw;x+=24) ctx.fillRect(x, vh - groundH, 12, groundH);

    // bird (circle + eye + wing)
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(bird.rot);
    // body
    ctx.fillStyle = '#ffd300';
    ctx.beginPath(); ctx.ellipse(0,0,bird.r*1.1,bird.r,0,0,Math.PI*2); ctx.fill();
    // belly
    ctx.fillStyle = '#fff1b8'; ctx.beginPath(); ctx.ellipse(-bird.r*0.2, bird.r*0.2, bird.r*0.6, bird.r*0.6, 0, 0, Math.PI*2); ctx.fill();
    // eye
    ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(bird.r*0.35, -bird.r*0.15, Math.max(2, bird.r*0.18), 0, Math.PI*2); ctx.fill();
    // beak
    ctx.fillStyle = '#ff8a00'; ctx.beginPath(); ctx.moveTo(bird.r*1.05, 0); ctx.lineTo(bird.r*1.55, -bird.r*0.35); ctx.lineTo(bird.r*1.55, bird.r*0.35); ctx.closePath(); ctx.fill();
    // wing
    ctx.fillStyle = '#f2c400'; ctx.beginPath(); ctx.ellipse(-bird.r*0.1, 3, bird.r*0.4, bird.r*0.25, Math.PI/3, 0, Math.PI*2); ctx.fill();

    ctx.restore();

    // score
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 36px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(score, vw * 0.5, 70);

    // best small
    ctx.font = '14px system-ui, Arial';
    ctx.textAlign = 'right';
    ctx.fillText('best: ' + best, vw - 12, 24);

    // overlays
    if (state === 'menu') {
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(vw*0.06, vh*0.22, vw*0.88 - vw*0.12, vh*0.46);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '28px system-ui, Arial';
      ctx.fillText('Toque para começar', vw*0.5, vh*0.38);
      ctx.font = '18px system-ui, Arial';
      ctx.fillText('Toque a tela para bater as asas', vw*0.5, vh*0.46);
      ctx.fillText('Som ativado no primeiro toque', vw*0.5, vh*0.52);
    } else if (state === 'over') {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, vh*0.28, vw, vh*0.44);
      ctx.fillStyle = '#fff';
      ctx.font = '32px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Fim de jogo', vw*0.5, vh*0.42);
      ctx.font = '20px system-ui, Arial';
      ctx.fillText(`Pontos: ${score}  —  Melhor: ${best}`, vw*0.5, vh*0.52);
      ctx.fillText('Toque para jogar de novo', vw*0.5, vh*0.6);
    }

    // tiny hint bottom
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.font = '12px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Toque em qualquer lugar → pular', vw*0.5, vh - 8);
  }

  function loop(now) {
    if(!lastTime) lastTime = now;
    const dt = Math.min(40, now - lastTime);
    lastTime = now;
    update(dt);
    ctx.clearRect(0,0,vw,vh);
    draw();
    requestAnimationFrame(loop);
  }

  // start
  reset();
  requestAnimationFrame(loop);

  // expose some quick tuning in console (opcional)
  window._flap = { bird, pipes, reset, startGame, spawnPipe };
})();
</script>
</body>
</html>
